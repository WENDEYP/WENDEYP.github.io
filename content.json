{"meta":{"title":"秋意已暮，寒冬将至","subtitle":"","description":"好好学习，天天向上","author":null,"url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"集合学习","slug":"集合学习","date":"2021-10-25T15:01:13.000Z","updated":"2021-11-13T14:22:48.947Z","comments":true,"path":"2021/10/25/集合学习/","link":"","permalink":"http://example.com/2021/10/25/%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"集合集合的理解和好处 数组 长度必须指定，一旦指定就不能更改 保存的为同一类型数据 使用数组增加删除时比较麻烦 集合 可以动态保存任意多个对象，使用比较方便 提供了一系列的操作对象的方法：add、remove、set、get等 使用集合添加删除代码简洁 集合的框架体系集合分为两组（单列集合和双列集合） Collection 接口有两个重要的子接口List和Set，他们实现的子类为单列集合 Map接口实现的子类为双列集合 Iterable(接口)&lt;—Collection（接口） Collection: List Set List: vector ArrayList LinKedList Set: TreeSet hashSet Map&lt;k,v&gt;： Hashtable&lt;k,v&gt; Properties HashMap&lt;k,v&gt; LinkedHashMap&lt;k,v&gt; TreeMap&lt;k.v&gt; Collection接口遍历方式1、使用迭代器 Iterator对象称为迭代器，主要用于遍历Collection集合中的元素 迭代器的执行原理 当退出while循环后iterator指向最后一个元素，若要再次使用迭代器，需要对其进行重置 iterator = collection.iterator(); 123456Iterator iterator = coll.iterator();//得到一个集合迭代器//hasNext();判断是否有下一个元素while(iterstor.hasNext())&#123; //hasNext()的作用：1.下移2.将下移以后集合位置上的元素返回 sout(iterator.hasNext());&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xxx.Collection;import java.util.*;public class Collection_1 &#123; public static void main(String[] args) &#123; Collection collection = new ArrayList(); collection.add(new Book(&quot;三国&quot;,&quot;罗贯中&quot;,10.1)); collection.add(new Book(&quot;水浒&quot;,&quot;施耐庵&quot;,10.1)); collection.add(new Book(&quot;西游&quot;,&quot;吴承&quot;,10.1)); System.out.println(&quot;coll=&quot;+collection); //遍历 Iterator iterator = collection.iterator();//得到一个集合迭代器 /* while(iterator.hasNext())&#123; //next()的作用：1.下移2.将下移以后集合位置上的元素返回 Object obj = iterator.next(); System.out.println(obj); &#125;*/ //生成while循环的快捷键=&gt;itit //显示快捷键的快捷按键=ctrl+j while (iterator.hasNext()) &#123; Object next = iterator.next(); System.out.println(next); &#125; &#125;&#125;class Book&#123; private String name; private String author; private double price; public Book(String name, String author, double price) &#123; this.name = name; this.author = author; this.price = price; &#125; @Override public String toString() &#123; return &quot;book&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, author=&#x27;&quot; + author + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125;&#125; 2.增强for循环 迭代器的简化 12345678910111213141516171819package com.xxx.Collection;import java.util.ArrayList;import java.util.Collection;public class Collection_2 &#123; public static void main(String[] args) &#123; Collection collection = new ArrayList(); collection.add(new Book(&quot;三国&quot;,&quot;罗贯中&quot;,10.1)); collection.add(new Book(&quot;水浒&quot;,&quot;施耐庵&quot;,10.1)); collection.add(new Book(&quot;西游&quot;,&quot;吴承&quot;,10.1)); for (Object book : collection)&#123; System.out.println(book); &#125; &#125;&#125; ArrayList 线程不安全，没有synchronize修饰 多线程时使用Vector，线程安全 ArrayList中维护了一个Object类型的数组elementData。transient Object[] elementData; 意味着什么数据都能放 当创建ArrayList对象是，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，扩容为10，如需再次扩容，则为elementData的1.5倍。 如果使用的为有参构造器，则初始为指定大小，如需扩容，则为elementData的1.5倍 Modifier and Type Method and Description boolean add(E e) 将指定的元素追加到此列表的末尾。 void add(int index, E element) 在此列表中的指定位置插入指定的元素。 boolean addAll(Collection&lt;? extends E&gt; c) 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 boolean addAll(int index, Collection&lt;? extends E&gt; c) 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 void clear() 从列表中删除所有元素。 Object clone() 返回此 ArrayList实例的浅拷贝。 boolean contains(Object o) 如果此列表包含指定的元素，则返回 true 。 void ensureCapacity(int minCapacity) 如果需要，增加此 ArrayList实例的容量，以确保它可以至少保存最小容量参数指定的元素数。 void forEach(Consumer&lt;? super E&gt; action) 对 Iterable的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常。 E get(int index) 返回此列表中指定位置的元素。 int indexOf(Object o) 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 boolean isEmpty() 如果此列表不包含元素，则返回 true 。 Iterator&lt;E&gt; iterator() 以正确的顺序返回该列表中的元素的迭代器。 int lastIndexOf(Object o) 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。 ListIterator&lt;E&gt; listIterator() 返回列表中的列表迭代器（按适当的顺序）。 ListIterator&lt;E&gt; listIterator(int index) 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 E remove(int index) 删除该列表中指定位置的元素。 boolean remove(Object o) 从列表中删除指定元素的第一个出现（如果存在）。 boolean removeAll(Collection&lt;?&gt; c) 从此列表中删除指定集合中包含的所有元素。 boolean removeIf(Predicate&lt;? super E&gt; filter) 删除满足给定谓词的此集合的所有元素。 protected void removeRange(int fromIndex, int toIndex) 从这个列表中删除所有索引在 fromIndex （含）和 toIndex之间的元素。 void replaceAll(UnaryOperator&lt;E&gt; operator) 将该列表的每个元素替换为将该运算符应用于该元素的结果。 boolean retainAll(Collection&lt;?&gt; c) 仅保留此列表中包含在指定集合中的元素。 E set(int index, E element) 用指定的元素替换此列表中指定位置的元素。 int size() 返回此列表中的元素数。 void sort(Comparator&lt;? super E&gt; c) 使用提供的 Comparator对此列表进行排序以比较元素。 Spliterator&lt;E&gt; spliterator() 在此列表中的元素上创建*late-binding和故障快速* Spliterator 。 List&lt;E&gt; subList(int fromIndex, int toIndex) 返回此列表中指定的 fromIndex （包括）和 toIndex之间的独占视图。 Object[] toArray() 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 &lt;T&gt; T[] toArray(T[] a) 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 void trimToSize() 修改这个 ArrayList实例的容量是列表的当前大小。 Vector Vector类的定义说明 ```javapublic class Vectorextends AbstractList implement List,RandomAccess,Cloneable,Serializable{} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154- Vector底层也是一个对象数组，pritected Object[] elementData;- Vector是线程同步的（即线程安全），Vector类的操作方法带有synchronized- 在开发中，需要线程同步安全时，优先考虑Vector- 如果使用无参，默认10，满后，按两倍扩容- 如果使用有参指定大小，满后按两倍扩容## ArrayList与Vector的比较（底层结构)| | 底层结构 | 版本 | 线程安全（同步）效率 | 扩容倍数 || --------- | -------------------- | ------ | :------------------: | :----------------------------------------------------------: || ArrayList | 可变数组（Object[]） | jdk1.2 | 不安全，效率高 | 无参构造器，则初始elementData容量为0，第一次添加，扩容为10，再次扩容，则为elementData的1.5倍。有参构造器，初始为指定大小，扩容，为elementData的1.5倍 || Vector | 可变数组（Object[]） | jdk1.0 | 安全，效率不高 | 如果使用无参，默认10，满后，按两倍扩容，如果使用有参指定大小，满后按两倍扩容 |## ArrayList与LinkedList的比较| | 底层结构 | 增删效率 | 改查的效率 || ---------- | -------- | ------------------ | ---------- || ArrayList | 可变数组 | 较低（数组扩容） | 较高 || LinkedList | 双向链表 | 较高，通过链表追加 | 较低 |**如何选择ArrayList和LinkedList：**- 如果改查操作多，选择ArrayList- 如果增删操作多，选择LinkedList- 一般来说，在程序中，80%-90%都是查询，因此大部分情况都选择ArrayList- 在项目中，根据业务灵活性可以一个模块使用ArrayList，另一个使用LinkedList# LinkedList**LinkedList的底层操作机制**- LinkedList底层维护了一个双向链表- LinkedList中维护了两个属性first，last分别指向首尾节点- 每个节点（Node对象），里面又维护了prev，next，item，三个属性，prev指向前一个，next指向后一个，最终实现双向链表- LinkedList元素的添加和删除不是通过数组完成，相对来说效率较高- - | Modifier and Type | Method and Description | | ----------------- | ------------------------------------------------------------ | | `boolean` | `add(E e)` 将指定的元素追加到此列表的末尾。 | | `void` | `add(int index, E element)` 在此列表中的指定位置插入指定的元素。 | | `boolean` | `addAll(Collection&lt;? extends E&gt; c)` 按照指定集合的迭代器返回的顺序将指定集合中的所有元素追加到此列表的末尾。 | | `boolean` | `addAll(int index, Collection&lt;? extends E&gt; c)` 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 | | `void` | `addFirst(E e)` 在该列表开头插入指定的元素。 | | `void` | `addLast(E e)` 将指定的元素追加到此列表的末尾。 | | `void` | `clear()` 从列表中删除所有元素。 | | `Object` | `clone()` 返回此 `LinkedList`的浅版本。 | | `boolean` | `contains(Object o)` 如果此列表包含指定的元素，则返回 `true` 。 | | `Iterator&lt;E&gt;` | `descendingIterator()` 以相反的顺序返回此deque中的元素的迭代器。 | | `E` | `element()` 检索但不删除此列表的头（第一个元素）。 | | `E` | `get(int index)` 返回此列表中指定位置的元素。 | | `E` | `getFirst()` 返回此列表中的第一个元素。 | | `E` | `getLast()` 返回此列表中的最后一个元素。 | | `int` | `indexOf(Object o)` 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 | | `int` | `lastIndexOf(Object o)` 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。 | | `ListIterator&lt;E&gt;` | `listIterator(int index)` 从列表中的指定位置开始，返回此列表中元素的列表迭代器（按适当的顺序）。 | | `boolean` | `offer(E e)` 将指定的元素添加为此列表的尾部（最后一个元素）。 | | `boolean` | `offerFirst(E e)` 在此列表的前面插入指定的元素。 | | `boolean` | `offerLast(E e)` 在该列表的末尾插入指定的元素。 | | `E` | `peek()` 检索但不删除此列表的头（第一个元素）。 | | `E` | `peekFirst()` 检索但不删除此列表的第一个元素，如果此列表为空，则返回 `null` 。 | | `E` | `peekLast()` 检索但不删除此列表的最后一个元素，如果此列表为空，则返回 `null` 。 | | `E` | `poll()` 检索并删除此列表的头（第一个元素）。 | | `E` | `pollFirst()` 检索并删除此列表的第一个元素，如果此列表为空，则返回 `null` 。 | | `E` | `pollLast()` 检索并删除此列表的最后一个元素，如果此列表为空，则返回 `null` 。 | | `E` | `pop()` 从此列表表示的堆栈中弹出一个元素。 | | `void` | `push(E e)` 将元素推送到由此列表表示的堆栈上。 | | `E` | `remove()` 检索并删除此列表的头（第一个元素）。 | | `E` | `remove(int index)` 删除该列表中指定位置的元素。 | | `boolean` | `remove(Object o)` 从列表中删除指定元素的第一个出现（如果存在）。 | | `E` | `removeFirst()` 从此列表中删除并返回第一个元素。 | | `boolean` | `removeFirstOccurrence(Object o)` 删除此列表中指定元素的第一个出现（从头到尾遍历列表时）。 | | `E` | `removeLast()` 从此列表中删除并返回最后一个元素。 | | `boolean` | `removeLastOccurrence(Object o)` 删除此列表中指定元素的最后一次出现（从头到尾遍历列表时）。 | | `E` | `set(int index, E element)` 用指定的元素替换此列表中指定位置的元素。 | | `int` | `size()` 返回此列表中的元素数。 | | `Spliterator&lt;E&gt;` | `spliterator()` 在此列表中的元素上创建*[late-binding](Spliterator.html#binding)*和*故障快速* [`Spliterator`](../../java/util/Spliterator.html) 。 | | `Object[]` | `toArray()` 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 | | `&lt;T&gt; T[]` | `toArray(T[] a)` 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 |# List- list接口是Collect接口的子接口- list集合类中的元素有序（添加取出顺序一致）且可以重复- list集合中的每个元素都有其对应的索引- list容器中的元素都对应一个整数型的序号，记载其在容器中的位置，可以根据序号取容器中的元素- 索引从0开始- - | Modifier and Type | Method and Description | | ------------------------ | ------------------------------------------------------------ | | `boolean` | `add(E e)` 将指定的元素追加到此列表的末尾（可选操作）。 | | `void` | `add(int index, E element)` 将指定的元素插入此列表中的指定位置（可选操作）。 | | `boolean` | `addAll(Collection&lt;? extends E&gt; c)` 按指定集合的迭代器（可选操作）返回的顺序将指定集合中的所有元素附加到此列表的末尾。 | | `boolean` | `addAll(int index, Collection&lt;? extends E&gt; c)` 将指定集合中的所有元素插入到此列表中的指定位置（可选操作）。 | | `void` | `clear()` 从此列表中删除所有元素（可选操作）。 | | `boolean` | `contains(Object o)` 如果此列表包含指定的元素，则返回 `true` 。 | | `boolean` | `containsAll(Collection&lt;?&gt; c)` 如果此列表包含指定 `集合的`所有元素，则返回true。 | | `boolean` | `equals(Object o)` 将指定的对象与此列表进行比较以获得相等性。 | | `E` | `get(int index)` 返回此列表中指定位置的元素。 | | `int` | `hashCode()` 返回此列表的哈希码值。 | | `int` | `indexOf(Object o)` 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 | | `boolean` | `isEmpty()` 如果此列表不包含元素，则返回 `true` 。 | | `Iterator&lt;E&gt;` | `iterator()` 以正确的顺序返回该列表中的元素的迭代器。 | | `int` | `lastIndexOf(Object o)` 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。 | | `ListIterator&lt;E&gt;` | `listIterator()` 返回列表中的列表迭代器（按适当的顺序）。 | | `ListIterator&lt;E&gt;` | `listIterator(int index)` 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 | | `E` | `remove(int index)` 删除该列表中指定位置的元素（可选操作）。 | | `boolean` | `remove(Object o)` 从列表中删除指定元素的第一个出现（如果存在）（可选操作）。 | | `boolean` | `removeAll(Collection&lt;?&gt; c)` 从此列表中删除包含在指定集合中的所有元素（可选操作）。 | | `default void` | `replaceAll(UnaryOperator&lt;E&gt; operator)` 将该列表的每个元素替换为将该运算符应用于该元素的结果。 | | `boolean` | `retainAll(Collection&lt;?&gt; c)` 仅保留此列表中包含在指定集合中的元素（可选操作）。 | | `E` | `set(int index, E element)` 用指定的元素（可选操作）替换此列表中指定位置的元素。 | | `int` | `size()` 返回此列表中的元素数。 | | `default void` | `sort(Comparator&lt;? super E&gt; c)` 使用随附的 `Comparator`排序此列表来比较元素。 | | `default Spliterator&lt;E&gt;` | `spliterator()` 在此列表中的元素上创建一个[`Spliterator`](../../java/util/Spliterator.html) 。 | | `List&lt;E&gt;` | `subList(int fromIndex, int toIndex)` 返回此列表中指定的 `fromIndex` （含）和 `toIndex`之间的视图。 | | `Object[]` | `toArray()` 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 | | `&lt;T&gt; T[]` | `toArray(T[] a)` 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 |# Set- 无序，没有索引- 不允许重复元素，所以最多包含一个null- 和List接口一样，Set也是Collection的子接口，因此，常用方法和Collection接口一样- Set接口的遍历方式 - 可以用迭代器 - 增强for循环 - 不能用索引方式获取## HashSetHashSet实现了Set接口,**添加元素机制**- 1.HashSet底层是HashMap- 2.添加一个元素时，先得到hash值，会转成索引- 3.找到存储数据表table，看这个索引的位置是否已经存放元素- 4.如果没有，直接加入- 5.如果有，调用equals比较，如果相同就放弃添加，如果不同则添加到最后- 6.在java8中，如果一条链表元素的个数超过TREEIFY_THRESHOLD（默认大小8），并且table的大小大于MIN_TREEIFY_CAPACITY（默认大小64），就会进行树化（红黑树0)**HashSet扩容转成红黑树机制**- HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（loadFactor0.75=12- 如果table数组使用到了临界值12，就会扩容到16乘2=32，新的临界值为32乘0.75=24，依次类推- 当链表个数达到8且table大小达到64才会进行树化，否则仍然采用数组扩容机制- 每加一次，扩容一次，当满足table达到64，再加数据table表不会扩容了，链表进行树化- Set接口实现类-HashSet联系 定义一个Employee类，包含private成员属性name，age要求： 1.创建3个Employee对象放入HashSet中2.当name和age的值相同时，认为是相同员工，不能添加到HashSet集合中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667```javapackage com.xxx.Set;import java.util.HashSet;import java.util.Objects;import java.util.Set;public class HashSetExercise &#123; public static void main(String[] args) &#123; HashSet hashSet = new HashSet(); hashSet.add(new Employee(&quot;milan&quot;,18)); hashSet.add(new Employee(&quot;smith&quot;,18)); hashSet.add(new Employee(&quot;milan&quot;,18)); System.out.println(&quot;HashSet=&quot;+hashSet); &#125;&#125;class Employee&#123; private String name; private int age; public Employee(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; //如果name和age相同则返回相同的hash值 @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; return age == employee.age &amp;&amp; Objects.equals(name, employee.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125;HashSet=[Employee&#123;name=&#x27;milan&#x27;, age=18&#125;, Employee&#123;name=&#x27;smith&#x27;, age=18&#125;] LinkedHashSet 1.linkedHashSet是HashSet的子类 2.LinkedHashSet的底层是LinkedHashMap，底层维护了一个数组+双链表的结构 LinkedHashSet根据元素的hashCode值来决定元素存储的位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序保存的 LinkedHashSet不允许添加重复元素 TreeSet123456789101112131415161718192021222324252627282930313233package com.xxx.Set;import java.util.Comparator;import java.util.TreeSet;@SuppressWarnings(&#123;&quot;all&quot;&#125;)public class TreeSet_ &#123; public static void main(String[] args) &#123; /** * 分析 * 1）当我们使用无参构造器时，创造TreeSet，依旧是无序是无序的 * 2）希望添加的元素，按照字符串大小来排序 * 3）使用TreeSet提供的一个构造器，可以传入一个比较器（匿名内部类 * 并指定排序规则 */// TreeSet treeSet = new TreeSet(); TreeSet treeSet = new TreeSet(new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; //调用String的compareTo方法进行字符串大小比较（从小到大，反过来则从大到小） return ((String)o1).compareTo((String) o2); //按长度大小则是 // return ((String)o1).length()-((String)o2).length(); &#125; &#125;); //添加数据 treeSet.add(&quot;jack&quot;); treeSet.add(&quot;tom&quot;); treeSet.add(&quot;sp&quot;); treeSet.add(&quot;a&quot;); System.out.println(&quot;treeSet=&quot;+treeSet); &#125;&#125; Map 1.Map与Collection并列存在，用来保存具有映射关系的Key-Value 2.Map中的&lt;Key,Value&gt;可以存放任何引用类型数据，会封装到HashMap$Node对象中 3.Map中的Key不允许重复，与HashSet类似。当有相同k是，等价于value的覆盖。 4.Map中的Value可以重复 5.Map中的Key只能一个为空，Value没有限制 6.常用String类作为Key，其他对象也可以为Key 7.&lt;K,V&gt;之间一一对应关系，通过指定的K能找到V 遍历方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.xxx.Map;import java.util.*;@SuppressWarnings(&#123;&quot;all&quot;&#125;)public class HashMap_ &#123; public static void main(String[] args) &#123; Map map = new HashMap(); map.put(&quot;邓超&quot;, &quot;孙俪&quot;); map.put(&quot;王宝强&quot;, &quot;马蓉&quot;); map.put(&quot;王&quot;, &quot;马&quot;); map.put(&quot;宝强&quot;, &quot;蓉&quot;); map.put(null, &quot;刘&quot;); map.put(&quot;路&quot;, null); //第一组：先取出所有的Key，通过Key取出对应的Value Set keyset = map.keySet(); //增强for System.out.println(&quot;-----第一种方式----------&quot;); for (Object key : keyset) &#123; System.out.println(key + &quot;-&quot; + map.get(key)); &#125; //2迭代器 System.out.println(&quot;--------第二种--------&quot;); Iterator iterator = keyset.iterator(); while (iterator.hasNext()) &#123; Object key = iterator.next(); System.out.println(key + &quot;-&quot; + map.get(key)); &#125; //第二组：把所有的value取出 Collection values = map.values(); //可以使用Collection的所有方法 //1增强for System.out.println(&quot;-------第三种，只能取到值---------&quot;); for (Object i : values) &#123; System.out.println(i); &#125; //2迭代器 System.out.println(&quot;-------第4种---------&quot;); Iterator iterator1 = values.iterator(); while (iterator1.hasNext()) &#123; Object next = iterator1.next(); System.out.println(next); &#125; //第三组：通过EntrySet来获取k-v Set entrySet = map.entrySet(); //增强for for (Object entry : entrySet) &#123; //将entry转成Map.Entry Map.Entry m = (Map.Entry) entry; System.out.println(m.getKey()+&quot; -&quot;+m.getValue()); &#125; //迭代器 Iterator iterator2 = entrySet.iterator(); while (iterator2.hasNext()) &#123; Object next = iterator2.next(); // System.out.println(next.getClass());转成Map.Entry,因为Map.Entry中提供了getK和getV的方法 Map.Entry m = (Map.Entry) next; System.out.println(m.getKey()+&quot;-&quot;+m.getValue()); &#125; &#125;&#125; HashMap 1.Map接口的常用实现类：HashMap、HashTable和Properties 2.HashMap是Map接口使用频率最高的实现类 3.HashMap是以K-V对的方式来存储数据（HashMap$Node类型） 4.与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储 5.Map中的Key不允许重复，与HashSet类似。当有相同k是，等价于value的覆盖。 6.Map中的Value可以重复 7.Map中的Key只能一个为空，Value没有限制 8.HashMap没有实现同步，因此是线程不安全了 TreeMap1234567891011121314151617181920212223242526272829303132package com.xxx.Map;import java.util.Comparator;import java.util.TreeMap;@SuppressWarnings(&#123;&quot;all&quot;&#125;)public class TreeMap_ &#123; public static void main(String[] args) &#123; /** * 分析 * 1）当我们使用无参构造器时，创造TreeMap，依旧是无序是无序的 * 2）希望添加的元素，按照字符串大小来排序 * 3）使用TreeMap提供的一个构造器，可以传入一个比较器（匿名内部类 * 并指定排序规则,根据Key来排 */// TreeSet treeSet = new TreeSet(); TreeMap treeMap = new TreeMap(new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; return ((String)o1).compareTo(((String) o2)); &#125; &#125;) ; //添加数据 treeMap.put(&quot;jack&quot;,&quot;的奇偶偶爱的&quot;); treeMap.put(&quot;tom&quot;,&quot;爱的&quot;); treeMap.put(&quot;jk&quot;,&quot;爱&quot;); treeMap.put(&quot;k&quot;,&quot;奇偶偶爱的&quot;); System.out.println(&quot;treeSet=&quot;+treeMap); &#125; &#125; HashTable 存放元素是键值对：即K-V hashTable的键和值都不能为空，否则会抛出NullPointException HashTable使用方法基本和HashMap一样 HashTable是线程安全的，实现了synchronize 底层是一个数组HashTable$Entry[] 初始化大小为11，临界值为8=11*0.75, 相较于HashMap效率较低 Properties 继承HashTable，k-v都不能为空 使用键值对，使用与上面类似 Properties可以从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改 xxx.properties文件通常为配置文件 Java 读写Properties配置文件 - 旭东的博客 - 博客园 (cnblogs.com) 开发中如何选择集合实现类在开发中选择什么样的集合主要取决于业务操作的特点，根据集合实现类的特性进行选择 1）先判断存储的类型（一组对象（单列）或一组键值对（双列）） 2）一组对象【单列】：Collection接口 允许重复：List 增删多：LinkedList（底层双向列表 该差多：ArrayList（Object可变数组 不允许重复:Set 无序：HashSet【底层HashMap，维护了一个哈希表（数组+链表+红黑树 排序;TreeSet 插入和取出一致：LinkedHashSet（底层LinkedHashMap底层(HashMap))，维护一个数组+双向链表 3）一组键值对【双列】：Map 键无序：HashMap(底层是：哈希表（jdk7：数组+链表，jdk8：数组+链表+红黑树) 键排序：TreeMap 键插入和取出顺序一致：LinkedHashMap 读取文件Properties Collections工具类 1）Collections是一个操作Set、List、Map等集合的工具类 2）Collections中提供了一系列静态的方法对集合元素类进行排序、查询和修改等操作 排序操作：（均为static方法） static void shuffle(List&lt;?&gt; list) 使用默认的随机源随机排列指定的列表。 static void shuffle(List&lt;?&gt; list) 使用默认的随机源随机排列指定的列表。 static void swap(List&lt;?&gt; list, int i, int j) 交换指定列表中指定位置的元素。 static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 根据指定的比较器引起的顺序对指定的列表进行排序。 static void` reverse(List&lt;?&gt; list) 反转指定列表中元素的顺序。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"JVM学习","slug":"JVM学习","date":"2021-10-24T14:50:51.000Z","updated":"2021-10-24T14:52:13.928Z","comments":true,"path":"2021/10/24/JVM学习/","link":"","permalink":"http://example.com/2021/10/24/JVM%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"native1234567891011121314151617181920212223242526package com.wu.pojo;public class Demo &#123; public static void main(String[] args) &#123; new Thread(()-&gt;&#123; &#125;,&quot;my thread name&quot;).start(); &#125; /** * native : 凡是带了native关键字的，说明java的作用范围达不到了，回去调用底层C语言库！ * 会进入本地方法栈 * 调用本地方法本地接口 JNI * JNI作用 ： 扩展java使用，会融合不同的语言为java所用！ 最初是C语言与C++ * java诞生时，C与C++横行，想要立足，必须有调用C与C++的程序 * 它在内存区域中专门开辟了一块标记区域：native Method stack（本地方法栈），登记native方法 * 在最终执行时加载本地方法库中的方法通过JNI * * java程序员驱动打印机时要使用native方法， 管理系统，掌握即可，在企业应用组少见 */ private native void Start0(); //调用其他接口： Socket， WebService， HTTP //eg： 球球爱心网： 输入（PHP）--&gt; NodeJS --&gt; Socket --&gt; C++ --&gt; 游戏刷爱心&#125; ##方法区 存放静态变量（static）、常量（final）、类信息（构造方法，接口定义）Class、常量池 #栈 先进后出，后进先出，如：桶 栈内存，主管程序的运行，生命周期和线程同步； 线程结束，栈内存释放，对于栈来说，不存在垃圾回收，一旦线程结束，栈就Over！ 栈存放的东西： 8大基本类型+对象的引用（地址）+实例方法 栈的运行原理：栈帧（百度学习） 栈满了 报错：StackOverFlowError#队列 先进先出（FIFO：first input First output），如排队，管道。 喝多了吐就是栈 吃多了拉就是队列 #堆 Heap，一个JVM只有一个堆内存，堆内存的大小可以调节 类加载器读取了类文件后，一般把（类，方法，常量，变量，保存我们所有引用类型的真实对象） 堆内存中分为三个区域 新生区（伊甸园区，幸存0区，幸存1区） 类：诞生和成长的地方，甚至死亡； 伊甸园，所有的对象都在伊甸园区new出来 幸存者区（0,1） 养老区 older 永久区 Perm ：这个区域常驻内存的，用来存放JDK自身携带的Class对象，interface元数据，存放java运行时的一些环境或类信息，这个区域不存在垃圾回收！关闭JVM虚拟就会释放这个区域的内存 一个启动类，加载了大量的第三方jar包，Tomcat部署了太多的应用，大量动态生成的反射类，不断的被加载，直到内存满，就会出现OOM错误 jdk1.6之前：永久代，常量池是在方法区； jdk1.7：永久代，但是慢慢退化了，去永久代，常量池在堆中 jdk.8之后：无永久代，常量池在元空间 元空间，逻辑上存在，物理上可能不存在 GC垃圾回收，主要在伊甸园区和养老区， 内存调优，-Xms1024m -Xmx1024M -XX:+printGCDetails 1234567891011121314151617181920package com.wu.pojo;public class HelloWorld &#123; public static void main(String[] args) &#123; //返回虚拟机试图使用的最大内存 long max = Runtime.getRuntime().maxMemory(); //字节 1024*1024 //返回JVM的初始化总内存 long total = Runtime.getRuntime().totalMemory(); System.out.println(&quot;max=&quot;+max+&quot;字节\\t&quot;+(max/(double)1024/1024)+&quot;MB&quot;); System.out.println(&quot;total=&quot;+max+&quot;字节\\t&quot;+(total/(double)1024/1024)+&quot;MB&quot;); //默认情况下；分配的总内存是电脑内存的1/4，初始化的内存为1/64 &#125; //OOM(内存满报错) // 1.尝试扩大堆内存，查看结果（-Xms1024m -Xmx1024m -XX:+PrintGCDetails） // 2.分析内存，看下哪个地方出问题（专业工具）&#125; 堆内存满了报错：OutOfMemoryError 在一个项目中，突然出现了OOM故障，排除问题 能够看到代码第几行出错：内存快照分析工具：MAT，Jprofiler Debug，一行一行分析（最慢） MAT,Jprofiler 作用 分析Dump内存文件，快速定位内存泄露 获得堆中数据 获得大的对象 Dump文件 -Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError -Xms 设置初始化内存分配大小，默认1/64 -Xmx 设置最大分配内存，默认1/4 -XX:+PrintGCDetails ,打印GC垃圾回收信息 -XX:+HeapDumpOnOutOfMemoryError #GC(垃圾自动回收) JVM进行GC时，并不是对三个区域统一回收，大部分时候回收新生代 GC两种类：轻GC（普通的GC），重GC（全局的GC） GC的算法：标记清除法，标记压缩，复制算法，引用计数器 每次GC都会讲伊甸园中活的对象移动到幸存区中；且Eden区被GC后，就会是空的 内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法 （时间复杂度） 内存整齐度：复制算法=标记压缩算法&gt;标记清除算法 内存利用率：标记压缩算法=标记清除算法&gt;复制算法 年轻代 存活率低 复制算法 老年代 区域大：存活率低 标记清除（内存碎片不是太多）+标记压缩 混合实","categories":[],"tags":[{"name":"转发","slug":"转发","permalink":"http://example.com/tags/%E8%BD%AC%E5%8F%91/"}]},{"title":"线程","slug":"线程","date":"2021-10-24T05:55:23.000Z","updated":"2021-10-25T01:39:22.468Z","comments":true,"path":"2021/10/24/线程/","link":"","permalink":"http://example.com/2021/10/24/%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"一个进程包含多个线程，线程的处理方式与cpu相关，当只有一个CPU时，不能并发的进行处理线程，只能来回切换 线程不一定立即执行，要听CPU调度 1、创建线程的方式1：继承Thread类1234567891011121314151617181920212223package com.xxx.Thread;/** * 创建线程的方式1：继承Thread类，通过new对象调用start（）启动 */public class ThreadTest1 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(&quot;子线程1111&quot;); &#125; &#125; public static void main(String[] args) &#123; ThreadTest1 threadTest1 = new ThreadTest1(); threadTest1.start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(&quot;执行主线程&quot;+ i); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.xxx.Thread;import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;import java.net.URL;/** * 练习Thread，实现多线程同步下载图片 */public class TestThread2 extends Thread&#123; private String url; // 网络图片地址 private String name; //保存文件名 public TestThread2(String url, String name) &#123; this.url = url; this.name = name; &#125; //下载图片线程的执行体 @Override public void run() &#123; WebDownLoader webDownLoader = new WebDownLoader(); webDownLoader.downloader(url,name); System.out.println(&quot;下载了文件名为：&quot; + name); &#125; public static void main(String[] args) &#123; TestThread2 testThread1 = new TestThread2(&quot;https://p1.ssl.qhimg.com/t01aa01f1bdc77cebca.png&quot;,&quot;2.png&quot;); TestThread2 testThread2 = new TestThread2(&quot;//img.1ting.com/images/special/40/d98c38951067dbdef7b50322972c7573.jpg&quot;,&quot;3.jpg&quot;); TestThread2 testThread3 = new TestThread2(&quot;//img.1ting.com/images/singer/s210_4754.jpg&quot;,&quot;1.jpg&quot;); testThread1.start(); testThread2.start(); testThread3.start(); &#125;&#125;//下载器class WebDownLoader&#123; //下载方法 public void downloader(String url, String name)&#123; try &#123; FileUtils.copyURLToFile(new URL(url),new File(name)); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println(&quot;downloader error&quot;); &#125; &#125;&#125; 2、创建线程方式2，实现Runnable接口12345678910111213141516171819202122232425package com.xxx.Thread;public class Test3Thread implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(&quot;子线程1111&quot;); &#125; &#125; public static void main(String[] args) &#123; //创建Runnable接口的实现类对象 Test3Thread test3Thread = new Test3Thread();// Thread thread = new Thread(test3Thread);// thread.start(); new Thread(test3Thread).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(&quot;执行主线程&quot;+ i); &#125; &#125;&#125; 模拟龟兔赛跑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xxx.Thread;/** * 模拟龟兔赛跑 */public class Race implements Runnable&#123;private static String winner;//获胜者 @Override public void run() &#123; //模拟兔子睡觉 if(Thread.currentThread().getName().equals(&quot;兔子&quot;))&#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for (int i = 0; i &lt;= 100; i ++)&#123;//模拟100步 boolean flag = gameOver(i); if (flag)&#123; break; &#125; System.out.println(Thread.currentThread().getName()+&quot;跑了&quot;+i+&quot;步&quot;); &#125; &#125; public boolean gameOver(int i )&#123;//游戏结束判定 if(winner != null)&#123; return true; &#125; &#123; if (i &gt;= 100) &#123; winner = Thread.currentThread().getName(); System.out.println(winner+&quot;获得了比赛胜利&quot;); System.out.println(&quot;游戏结束&quot;); return true; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; Race race = new Race();//创建跑道，兔子和乌龟一起跑 new Thread(race,&quot;兔子&quot;).start();//创建兔子线程 new Thread(race,&quot;乌龟&quot;).start();//创建乌龟线程 &#125;&#125; 3、创建线程方式3：实现Callable接口12345671、实现Callable接口，需要返回值类型2、重写call方法，需要抛出异常3、创建目标对象4、创建执行服务：ExecutorService ser= Executors.newFixedThreadPool(1);5、提交执行：Future&lt;Boolean&gt; result1 = ser.submit(t1);6、获取结果：boolean r1 = result1.get();7、关闭服务：ser.shutdownNow(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.xxx.Thread;/** * 线程创建的方式3， 实现callable接口 */import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;import java.net.URL;import java.util.concurrent.*;public class TestCallable implements Callable&lt;Boolean&gt; &#123; private String url; // 网络图片地址 private String name; //保存文件名 public TestCallable(String url, String name) &#123; this.url = url; this.name = name; &#125; //下载图片线程的执行体 @Override public Boolean call() &#123; WebDownLoader webDownLoader = new WebDownLoader(); webDownLoader.downloader(url,name); System.out.println(&quot;下载了文件名为：&quot; + name); return true; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; TestCallable t1 = new TestCallable(&quot;https://p1.ssl.qhimg.com/t01aa01f1bdc77cebca.png&quot;,&quot;2.png&quot;); TestCallable t2 = new TestCallable(&quot;//img.1ting.com/images/special/40/d98c38951067dbdef7b50322972c7573.jpg&quot;,&quot;3.jpg&quot;); TestCallable t3 = new TestCallable(&quot;//img.1ting.com/images/singer/s210_4754.jpg&quot;,&quot;1.jpg&quot;); //创建执行服务：(参数代表线程的数目 ExecutorService ser = Executors.newFixedThreadPool(3); //提交执行 Future&lt;Boolean&gt; r1 = ser.submit(t1); Future&lt;Boolean&gt; r2 = ser.submit(t2); Future&lt;Boolean&gt; r3 = ser.submit(t3); //获取结果 boolean rs1 = r1.get(); boolean rs2 = r2.get(); boolean rs3 = r3.get(); //关闭服务 ser.shutdownNow(); &#125;&#125;//下载器class WebDownLoader1&#123; //下载方法 public void downloader(String url, String name)&#123; try &#123; FileUtils.copyURLToFile(new URL(url),new File(name)); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println(&quot;downloader error&quot;); &#125; &#125;&#125; 静态代理模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.xxx.Thread;/** * 静态代理模式 * 真实对象和代理对象都要实现同一个接口 * 代理对象要代理真实的角色 * 好处： 代理对象可以做很多真实对象做不了的事情 真实对象专注做自己的事情 */public class StaticProxy &#123; public static void main(String[] args) &#123; //原来的方法 System.out.println(&quot;原来的方法===========================&quot;); You you = new You(); you.HappyMarry(); //代理方法 System.out.println(&quot;代理方法===========================&quot;); WeddingCompany weddingCompany = new WeddingCompany(new You()); weddingCompany.HappyMarry(); &#125;&#125;interface Marry&#123; void HappyMarry();&#125;//真实角色，你去结婚class You implements Marry&#123; @Override public void HappyMarry() &#123; System.out.println(&quot;开心的结婚&quot;); &#125;&#125;//代理角色，帮助你结婚class WeddingCompany implements Marry&#123; //代理谁-》真实目标角色 private Marry target; public WeddingCompany(Marry target) &#123; this.target = target; &#125; @Override public void HappyMarry() &#123; before(); this.target.HappyMarry(); after(); &#125; private void after() &#123; System.out.println(&quot;结婚之后&quot;); &#125; private void before() &#123; System.out.println(&quot;结婚之前&quot;); &#125;&#125; 123456原来的方法===========================开心的结婚代理方法===========================结婚之前开心的结婚结婚之后 推导Lambada表达式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.xxx.Thread;/** * 推导Lambada表达式 */public class TestLambada1 &#123; //3.静态内部类 static class Like2 implements ILike&#123; @Override public void lambada() &#123; System.out.println(&quot;I Like Lambada&quot;); &#125; &#125; public static void main(String[] args) &#123; ILike like = new Like(); like.lambada(); like = new Like2(); like.lambada(); //4.局部内部类 class Like3 implements ILike&#123; @Override public void lambada() &#123; System.out.println(&quot;I Like Lambada&quot;); &#125; &#125; like = new Like3(); like.lambada(); //5.匿名内部类，没有类的名称，必须借助接口或者父类 like = new ILike() &#123; @Override public void lambada() &#123; System.out.println(&quot;I Like Lambada5&quot;); &#125; &#125;; like.lambada(); //6.用lambada简化 like = ()-&gt; &#123; System.out.println(&quot;I Like Lambada6&quot;); &#125;; like.lambada(); &#125;&#125;//1.定义一个函数式接口interface ILike&#123; void lambada();&#125;//2.实现类class Like implements ILike&#123; @Override public void lambada() &#123; System.out.println(&quot;I Like Lambada&quot;); &#125;&#125; 12345678910111213141516171819202122package com.xxx.Thread;//匿名内部类//模板// 接口 名 = new 接口()&#123;// 重写接口方法；// &#125;public class TestLambada2 &#123; public static void main(String[] args) &#123; ILove love = new ILove() &#123; @Override public void love(int a) &#123; System.out.println(&quot;I love you--&gt;&quot; + a); &#125; &#125;; love.love(2); &#125;&#125;interface ILove&#123; void love(int a);&#125; Lambada简化123456总结： Lambada表达式的模板 接口 名 = （接口参数）&#123;执行的代码&#125;; Lambada表达式只能有一行代码的情况下才能简化成一行，如果有多行，那么就用代码块包裹 Lambada使用的前提是接口为函数式接口（即只有一个方法接口） 多个参数也可以去掉参数类型，去掉得都去掉 12345678910111213141516package com.xxx.Thread;/** * Lambada简化 */public class TestLambada2 &#123; public static void main(String[] args) &#123; ILove love = (int a)-&gt; &#123; System.out.println(&quot;I Love You-&gt;&quot;+ a); &#125;; love.love(2); &#125;&#125;interface ILove&#123; void love(int a);&#125; 4、线程的状态（5大状态）1234567891011121、创建状态 （new 的时候为创建状态，即新生）2、就绪状态 当调用start()方法时，线程立即进入就绪状态，但并不是立即调度执行3、运行状态 处于就绪状态的线程经由CPU调度到达运行状态 进入运行状态，线程才真正执行线程体的代码块4、阻塞状态 当调用sleep，wait或同步锁定时，线程进入阻塞状态，就是代码不往下执行，阻塞事件解除后， 重新进入就绪状态等待CPU调度执行5、死亡状态 线程中断或者结束，一旦进入死亡状态，就不能再重新启动 4.1线程停止1234567891011121314151617181920212223242526272829303132333435363738package com.xxx.Thread1;/** * 测试stop * 1.建议正常停止---&gt;利用次数，不建议死循环。 * 2.建议使用标志位---》设置一个标志位 * 3.不要使用stop等过时或JDK不推荐使用的方法 */public class TestStop implements Runnable&#123; //1.设置标志位 private boolean flag = true; @Override public void run() &#123; int i = 0; while (flag)&#123; System.out.println(&quot;run.......Thread&quot;+ i++); &#125; &#125; //设置一个公开的线程停止方法，转换标志位 public void stop()&#123; this.flag = false; &#125; public static void main(String[] args) &#123; TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0 ; i &lt; 1000; i ++ )&#123; System.out.println(&quot;main&quot; + i); if (i == 900)&#123; //调用stop方法切换标志位，让线程停止 testStop.stop(); System.out.println(&quot;线程停止&quot;); &#125; &#125; &#125;&#125; 4.2 Thread.sleep()123456789101112131415161718192021222324252627282930313233package com.xxx.Thread1;import java.text.SimpleDateFormat;import java.util.Date;//模拟倒计时public class TestSleep1 &#123; public static void main(String[] args) &#123; //打印当前系统时间 Date startTime = new Date(System.currentTimeMillis());//获取当前时间 while (true)&#123; try &#123; Thread.sleep(1000); System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime)); startTime = new Date(System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //模拟倒计时 public static void tenDown() throws InterruptedException &#123; int num = 10; while(true)&#123; Thread.sleep(1000); System.out.println(num--); if (num &lt;= 0)&#123; break; &#125; &#125; &#125;&#125; 4.3礼让线程（yeld 123456789101112131415161718192021222324252627礼让线程，让当前正在执行的线程暂停，但不阻塞将线程从运行状态转化为就绪状态让CPU重新调度，礼让不一定成功，看CPU心情 package com.xxx.Thread1;/** * 测试礼让线程 * 礼让不一定成功 */public class ThreadYield &#123; public static void main(String[] args) &#123; MyYield myYield = new MyYield(); new Thread(myYield,&quot;A&quot;).start(); new Thread(myYield,&quot;B&quot;).start(); &#125;&#125;class MyYield implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;); &#125;&#125; 4.4 Join 强制执行1本来线程是共同竞争CPU调度，当采用Join（）方法时，让插入线程执行完（其他线程阻塞），再执行别的线程 123456789101112131415161718192021222324252627package com.xxx.Thread1;/** * 测试Join，想象为插队 */public class ThreadJoin implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++)&#123; System.out.println(&quot;VIP线程&quot;+ i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ThreadJoin threadJoin = new ThreadJoin(); Thread thread = new Thread(threadJoin); thread.start(); for (int i = 0; i &lt; 1000; i++)&#123; if (i == 200)&#123; thread.join(); &#125; System.out.println(Thread.currentThread().getName() + i); &#125; &#125;&#125; 4.5 测试线程状态123456789101112131415161718192021222324252627282930313233package com.xxx.state;/** * 测试观察线程的状态 */public class State &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;=========&quot;); &#125;); //观察状态 Thread.State state = thread.getState(); System.out.println(state);//NEW thread.start();//启动线程 Thread.State state1 = thread.getState(); System.out.println(state1); while (state != Thread.State.TERMINATED)&#123;//只要线程不终止，就一直执行 Thread.sleep(100); state = thread.getState();//更新线程状态 System.out.println(state);//输出状态 &#125; &#125;&#125; 4.6 测试优先级1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.xxx.Thread1;public class TestPriority &#123; public static void main(String[] args) &#123; //主线程，默认优先级--》5 System.out.println(Thread.currentThread().getName() +&quot;-&gt;&quot;+Thread.currentThread().getPriority() ); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); Thread t6 = new Thread(myPriority); //设置优先级 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(4); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); &#125;&#125;class MyPriority implements Runnable&#123; @Override public void run() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() +&quot;-&gt;&quot;+Thread.currentThread().getPriority() ); &#125;&#125; 4.7 测试守护线程1234线程分为用户线程和守护线程虚拟机必须保证用户线程执行完毕虚拟机不用等待守护线程执行完毕守护线程有：后台记录操作日志，监控内存，垃圾回收等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.xxx.Thread1;/** * 测试守护线程 * 党守护你 */public class TestDaemon &#123; public static void main(String[] args) &#123; Dang dang = new Dang(); You you = new You(); Thread thread = new Thread(dang); thread.setDaemon(true);//默认识false为用户线程，设置true变为守护线程 thread.start();//守护线程启动 new Thread(you).start();//用户线程你启动 &#125;&#125;//党class Dang implements Runnable&#123; @Override public void run() &#123; while (true)&#123; System.out.println(&quot;baohuni &quot;); &#125; &#125;&#125;//你class You implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 36500; i++)&#123; System.out.println(&quot;开心的或者&quot;); &#125; System.out.println(&quot;=======goodbye! world========&quot;); &#125;&#125; 4.8线程同步123并发：同一个对象被多个线程同时操作线程同步的安全性：对列+锁sleep()能放大问题的不安全性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.xxx.Thread1;public class UnsafeBuyTicket &#123; public static void main(String[] args) &#123; BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket,&quot;A&quot;).start(); new Thread(buyTicket,&quot;B&quot;).start(); new Thread(buyTicket,&quot;C&quot;).start(); &#125;&#125;class BuyTicket implements Runnable&#123; private int ticketNums = 10; private boolean flag = true; @Override public void run() &#123; //买票 while (flag) &#123; buy(); &#125; &#125; private void buy()&#123; if (ticketNums &lt;= 0)&#123;//判断是否有票 flag = false; return; &#125; //模拟延时 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //买票 System.out.println(Thread.currentThread().getName()+&quot;买了第&quot;+ticketNums-- +&quot;张票&quot;); &#125;&#125;//线程不安全，有人拿到同一张票C买了第9张票B买了第9张票A买了第10张票A买了第8张票B买了第7张票C买了第7张票C买了第5张票A买了第6张票B买了第5张票A买了第4张票C买了第4张票B买了第4张票B买了第2张票C买了第1张票A买了第3张票Process finished with exit code 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.xxx.Thread1;public class UnsafeBank &#123; public static void main(String[] args) &#123; //账户 Account account = new Account(100,&quot;基金&quot;); Drawing you = new Drawing(account,50,&quot;你&quot;); Drawing girlfriend = new Drawing(account,100,&quot;girlfriend&quot;); you.start(); girlfriend.start(); &#125;&#125;//账户class Account &#123; int money; //余额 String name; // 卡名 public Account(int money, String name) &#123; this.money = money; this.name = name; &#125;&#125;//银行：银行取款class Drawing extends Thread&#123; Account account ;//账户 //取了多少钱 int drawingMoney ; //现在手里有多少钱 int nowMoney; public Drawing(Account account, int drawingMoney, String name) &#123; super(name); this.account = account; this.drawingMoney = drawingMoney; &#125; //取钱 @Override public void run() &#123; //判断有没有钱 if (account.money - drawingMoney &lt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够，再见&quot;); return; &#125; //模拟延时 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //卡内余额 account.money = account.money - drawingMoney; //手里的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+ &quot;余额为&quot;+ account.money); //Thread.currentThread().getName()=this.getName();因为继承了Thread类 System.out.println(this.getName()+&quot;手里的钱&quot;+nowMoney); &#125;&#125;基金余额为-50girlfriend手里的钱100基金余额为-50你手里的钱50 12345678910111213141516171819202122//线程不安全的List集合package com.xxx.Thread1;import java.util.ArrayList;import java.util.List;public class UnsafeArrayList &#123; public static void main(String[] args) throws InterruptedException &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10000; i++)&#123; new Thread(()-&gt;&#123; list.add(Thread.currentThread().getName()); &#125;).start(); &#125; Thread.sleep(1000); System.out.println(list.size()); &#125;&#125;9996 4.9同步方法synchronized线程安全 synchronized 控制对“对象”的访问，每个对象都有一把锁，每个synchronized方法都必须获得调用方法才能执行，否则会线程阻塞，方法一旦执行就独占该锁，知道方法返回才释放该锁，后面的阻塞线程才能获得这个锁继续执行缺陷：若将一个方法申明为synchronized将会影响效率同步块：synchronized(Obj){} Obj可以是任何对象，但是推荐共享的资源作为同步监视器，如上面的账户 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class 同步监视器的执行过程 1、第一个线程访问，锁定同步监视器，执行其中的代码 2、第二个线程访问，发现同步监视器被锁定，无法访问 3、第一个线程访问完毕，解锁同步监视器 4、第二个线程访问，发现同步监视器没有锁，然后锁定并访问 123456789101112131415private synchronized void buy()&#123; if (ticketNums &lt;= 0)&#123;//判断是否有票 flag = false; return; &#125; //模拟延时 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //买票 System.out.println(Thread.currentThread().getName()+&quot;买了第&quot;+ticketNums-- +&quot;张票&quot;); &#125; 12345678910111213141516synchronized (account)&#123; //判断有没有钱 if (account.money - drawingMoney &lt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够，再见&quot;); return; &#125; //卡内余额 account.money = account.money - drawingMoney; //手里的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+ &quot;余额为&quot;+ account.money); //Thread.currentThread().getName()=this.getName();因为继承了Thread类 System.out.println(this.getName()+&quot;手里的钱&quot;+nowMoney); &#125; 4.10死锁 多个线程互相抱着对方所需的资源，然后形成僵持 产生死锁的4个必要条件 1、互斥条件：一个资源每次只能被一个进程使用 2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放 3、不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。 4、循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系 只要破坏其中任意一个或多个条件，就可以避免死锁的发生 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.xxx.Thread1;public class DeadLock &#123; public static void main(String[] args) &#123; Makeup g1 = new Makeup(0, &quot;灰姑凉&quot;); Makeup g2 = new Makeup(1, &quot;白雪公主&quot;); g1.start(); g2.start(); &#125;&#125;//口红class Lipstick&#123;&#125;//镜子class Mirror&#123;&#125;//化妆class Makeup extends Thread&#123; static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice; // 选择 String girlName; //使用化妆品的人 Makeup(int choice, String girlName)&#123; this.choice = choice; this.girlName = girlName; &#125; @Override public void run() &#123; //化妆 try &#123; makeup(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //化妆，互相持有对方的锁，需要拿到对方的资源 private void makeup() throws InterruptedException &#123; if (choice == 0)&#123; synchronized (lipstick)&#123;//获得口红的锁 System.out.println(this.girlName+&quot;获得口红的锁&quot;); Thread.sleep(1000); synchronized (mirror)&#123;//一秒钟后想获得镜子 System.out.println(this.girlName+&quot;一秒钟后想获得镜子&quot;); &#125; &#125; &#125; else &#123; synchronized (mirror)&#123;//获得口红的锁 System.out.println(this.girlName+&quot;获得镜子的锁&quot;); Thread.sleep(2000); synchronized (lipstick)&#123;//2秒钟后想获得口红 System.out.println(this.girlName+&quot;2秒钟后想获得口红&quot;); &#125; &#125; &#125; &#125;&#125; 4.11lock（锁）可重入锁 ReentrantLock类实现了Lock锁，它拥有与synchronized相同的并发性和内存语义，在实现线程的安全控制中，比较常用的是RReentrantLock，可以显示的加锁，释放锁 加锁之后要结束 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.xxx.Thread1;import java.util.concurrent.locks.ReentrantLock;/*测试lock锁 */public class TestLock &#123; public static void main(String[] args) &#123; TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); &#125;&#125;class TestLock2 implements Runnable&#123; int ticketNum = 10; //定义lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; try &#123; lock.lock();//加锁 if (ticketNum &gt; 0) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(ticketNum--); &#125; else &#123; break; &#125; &#125; finally &#123; lock.unlock();//解锁 &#125; &#125; &#125;&#125; 4.12synchronized与Lock的对比 Lock是显示锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供更多子类 优先使用顺序 Lock&gt;同步代码块（已经进入礼让方法体，分配了相应的资源）&gt;同步方法（在方法体之外) 5、线程协作5.1线程通信应用场景：生产者和消费者问题 假设仓库只能放一件产品，生产者生产出来产品放入仓库，消费者将产品从仓库中取走消费 如果仓库中没有产品，则生产者将产品放入仓库，否则继续等待，直到仓库中的产品被消费为止 如果仓库中有产品，则消费者可以取走消费，否则停止消费并等待，直到仓库中再次放入产品 这是一个线程同步问题，生产者和消费者共享了同一个资源，并且生产者和消费者之间相互依赖，互为条件。 分析 对于生产者，没有生产产品之前要通知消费者等待，生产了产品之后，又要马上通知消费者消费 对于消费者同理 synchronized不够解决此问题 synchronized可以阻止并发更新同个共享资源，实现了同步 synchronized不能用来实现不同线程之间的消息传递（通信） Java中提供了几个方法来解决线程中的通信问题 方法名 作用 wait() 表示线程一直等待，知道其他线程通知，与sleep不同，会释放锁 wait(long timeout) 指定等待的毫秒数 notify() 唤醒一个处于等待状态的线程 notifyAll() 唤醒同一个对象上所有调用Wait()方法的线程，优先级别高的线程优先调度 解决方式1 并发协作模型“生产者/消费者模式”—-&gt;管程法 生产者：负责生产数据的模块（可能是方法，对象，线程，进程 消费者：负责处理数据的模块（可能是方法，对象，线程，进程 缓冲区：消费者不能直接使用生产数据，中间有个缓存区 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.xxx.Thread1;/** * 并发协作模型“生产者/消费者模式”----&gt;管程法 */public class TestPc &#123; public static void main(String[] args) &#123; SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); &#125;&#125;//生产者class Productor extends Thread&#123; SynContainer container; public Productor(SynContainer container) &#123; this.container = container; &#125; //生产 @Override public void run() &#123; for (int i = 0; i &lt; 100; i ++)&#123; try &#123; container.push(new Chicken(i)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;生产了&quot;+ i +&quot;只鸡&quot;); &#125; &#125;&#125;//消费者class Consumer extends Thread&#123; SynContainer container; public Consumer(SynContainer container) &#123; this.container = container; &#125; //消费 @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; try &#123; System.out.println(&quot;消费了--》&quot;+ container.pop().no+&quot;只鸡&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//产品class Chicken&#123; int no; //编号 public Chicken(int no) &#123; this.no = no; &#125;&#125;//缓存区class SynContainer&#123; //容器大小 Chicken[] chickens = new Chicken[10]; //计数器 int count = 0; //生产者放入产品 public synchronized void push(Chicken chicken) throws InterruptedException &#123; //如果容器满了，就需要等待消费 if(count == chickens.length)&#123; //通知消费者，生产等待 this.wait(); &#125; //没有满 chickens[count] = chicken; count++; //可以通知消费 this.notifyAll(); &#125; //消费者消费 public synchronized Chicken pop() throws InterruptedException &#123; //判断能否消费 if (count== 0)&#123; //通知生产，消费等待 this.wait(); &#125; //可以消费 count--; Chicken chicken = chickens[count]; //吃完了，通知生产 this.notifyAll(); return chicken; &#125;&#125; 信号灯法，标志位解决 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.xxx.Thread1;/** * 信号灯法，标志位解决 */public class TestPc2 &#123; public static void main(String[] args) &#123; Tv tv = new Tv(); new Player(tv).start(); new Watcher(tv).start(); &#125;&#125;//生产者-&gt;演员class Player extends Thread&#123; Tv tv; public Player(Tv tv) &#123; this.tv = tv; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (i%2==0)&#123; this.tv.play(&quot;快乐大本营&quot;); &#125;else &#123; this.tv.play(&quot;广告&quot;); &#125; &#125; &#125;&#125;//消费者-&gt;观众class Watcher extends Thread&#123; Tv tv; public Watcher(Tv tv) &#123; this.tv = tv; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; try &#123; tv.watch(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//产品--&gt;节目class Tv&#123; //演员表演，观众等待 //观众观看，演员等待 String voice; //节目 boolean flag = true; //真为演员表演,观众等待 //表演 public synchronized void play(String voice)&#123; if (!flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;演员表演了：&quot;+voice); //通知观众看 this.notifyAll();//通知唤醒 this.voice = voice; this.flag = !this.flag; &#125; //观看 public synchronized void watch() throws InterruptedException &#123; if (flag)&#123; this.wait(); &#125; System.out.println(&quot;观看了：&quot;+voice); //通知演员表演 this.notifyAll(); this.flag = !this.flag; &#125;&#125; 6、线程池 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池子中，可以避免频繁的创建销毁，实现重复利用，类似于生活中的交通工具 好处 提高了响应速度（减少创建线程的时间 降低资源消耗（重复利用 便于线程管理（······） corePoolSize:核心池的大小 maxmumPoolSize:最大线程数 keepAliveTime:线程没有任务时最多保存多长时间会终止 使用线程池 JDK5.0起提供了线程相关的API：ExecutorService和Executors ExecutorService:真正的线程池接口。常见的子类ThreadPoolExecutor void execute(Runnable command) : 执行任务/命令，没有返回值，一般用来执行Runable Futuresubmit(Callabletask)：执行任务，一般用来执行Callable void shutdown()：关闭连接池 Executors:工具类、线程池的工厂，用来创建并返回不同类型的线程池 12345678910111213141516171819202122232425262728293031323334ackage com.xxx.Thread1;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 测试线程池 */public class TestPool &#123; public static void main(String[] args) &#123; //1.创建服务，创建线程池 ExecutorService service = Executors.newFixedThreadPool(10);//参数为线程池大小 //执行 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //2.关闭连接 service.shutdown(); &#125;&#125;class MyThread implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125;&#125;","categories":[],"tags":[{"name":"-导航 -分享","slug":"导航-分享","permalink":"http://example.com/tags/%E5%AF%BC%E8%88%AA-%E5%88%86%E4%BA%AB/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-24T03:31:35.840Z","updated":"2021-10-24T03:31:35.840Z","comments":true,"path":"2021/10/24/hello-world/","link":"","permalink":"http://example.com/2021/10/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"转发","slug":"转发","permalink":"http://example.com/tags/%E8%BD%AC%E5%8F%91/"},{"name":"-导航 -分享","slug":"导航-分享","permalink":"http://example.com/tags/%E5%AF%BC%E8%88%AA-%E5%88%86%E4%BA%AB/"}]}